Web のセキュリティモデルは[同一生成元ポリシー](http://ja.wikipedia.org/wiki/%E5%90%8C%E4%B8%80%E7%94%9F%E6%88%90%E5%85%83%E3%83%9D%E3%83%AA%E3%82%B7%E3%83%BC)に根ざしています。`https://mybank.com` 上のコードは `https://mybank.com` のデータのみアクセスでき、`https://evil.example.com` へのアクセスは決して許可されません。どのオリジンも残りの Web の世界からは切り離されており、自由に組み立て、遊べるサンドボックスを開発者に提供しています。理論的にはこれは完璧に輝いていますが、実践的には攻撃者はシステムを破壊するために様々な頭のいい方法を見つけてきました。

[クロスサイトスクリプティング (XSS)](http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%82%B9%E3%82%B5%E3%82%A4%E3%83%88%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0) は、サイトをうまくだまし同一生成元ポリシーを回避した上で、悪意のあるコードや攻撃者の意図したコードを注入する攻撃です。ブラウザはページ上に現れるコードは全て、そのページのセキュリティオリジンの一部であると信頼するので、これはとても大きな問題です。[XSS Cheat Sheet](http://ha.ckers.org/xss.html) は古いですが、攻撃者が悪意のあるコードを注入することで、その信頼を破る手法の代表例が載っています。_どんな_コードでも攻撃者が注入することに成功した場合、実質ゲームオーバーです。例えばユーザーのセッションデータが抜き取られたり、秘密にしておきたい情報が悪いヤツ™の手に渡ったりしてしまいます。我々開発者は可能ならそういったことは避けたいですよね。

このチュートリアルではそういった XSS のリスクをモダンブラウザで著しく下げることができる期待の新しい防御手法 Content Security Policy (CSP) を紹介したいと思います。

## ソースホワイトリスト

XSS の核心的な問題は、あなたのアプリケーションが用意したスクリプトと、攻撃者が注入した悪意あるスクリプトをブラウザが区別することができないことにあります。例えばこの記事の上部にある Google +1 ボタンは `https://apis.google.com/js/plusone.js` から取得したコードをこのページのオリジンのコンテキストで実行します。私達ならばそのコードを信頼できますが、ブラウザが `apis.google.com` から取得したコードは問題なく、`apis.evil.example.com` から取得したコードは問題がある、なんてことを理解できません。ブラウザは取得元に関係なく、ページがリクエストしたコードを喜んでダウンロードし、実行するでしょう。

サーバーが運んできた_全て_のものを盲目的に信用する代わりに、CSP が定義する `Content-Security-Policy` という HTTP ヘッダを使用し、信頼できる取得元のホワイトリストを作ることで、そこから取得したリソースのみ実行もしくはレンダリングすることをブラウザに指示することが出来ます。たとえ攻撃者がスクリプトを注入できるセキュリティホールを見つけられたとしても、そのスクリプトはホワイトリストにマッチせず、実行されることはありません。

自分のサイトと `apis.google.com` は問題のないコードを運んでると信頼できるので、それらいずれかのスクリプトは実行できるようにポリシーを定義してみましょう。

    Content-Security-Policy: script-src 'self' https://apis.google.com

簡単ですよね？
